
# Duck-Core 项目架构文档

> 大家好，今天我将为大家深入剖析一个名为 `duck-core` 的项目。这是一个前后端分离的 Web 应用，其独特之处在于前端采用了一种类似游戏引擎的实体-组件-系统（ECS）架构来构建一个可交互的画布，而后端则采用了分层清晰的 Go 语言微服务架构。
>
> 希望通过本文，能给大家在构建复杂前端应用和 Go 服务时带来一些启发。

## 1. 总体架构

`duck-core` 项目在宏观上是一个经典的前后端分离架构，通过 Docker Compose 进行容器化编排，整个技术栈由三个核心服务组成：

-   **`frontend` (Web 服务)**: 一个基于 React 和 TypeScript 的现代化前端应用，负责用户界面的渲染和交互。
-   **`backend` (后端服务)**: 一个使用 Go 语言编写的高性能后端服务，为前端提供 API 接口和业务逻辑处理。
-   **`db` (数据库服务)**: 使用 MySQL 8.0 作为持久化存储的数据库。

### 架构图

我们可以用下面的文字图来描述这几个服务之间的关系：

```
+-------------------------------------------------------------------+
|                           用户 (User)                             |
+-------------------------------------------------------------------+
              | (HTTPS/HTTP, Port 3000)
              v
+-------------------------------------------------------------------+
|                      Frontend (React + Vite)                      |
|      +-------------------------------------------------------+    |
|      |                 Canvas (ECS 架构)                     |    |
|      |   +----------+   +-----------+   +------------+       |    |
|      |   | Entities | - | Components| - |  Systems   |       |    |
|      |   +----------+   +-----------+   +------------+       |    |
|      +-------------------------------------------------------+    |
|                               | (HTTP API, Port 8080)             |
+-------------------------------|-----------------------------------+
                                v
+-------------------------------------------------------------------+
|                       Backend (Go + Gin)                          |
|      +-------------------------------------------------------+    |
|      |                        Router                           |    |
|      +-------------------------------------------------------+    |
|      |                      Middleware                         |    |
|      +-------------------------------------------------------+    |
|      |                       Handler                           |    |
|      +-------------------------------------------------------+    |
|      |                       Service                           |    |
|      +-------------------------------------------------------+    |
|      |                      Repository                         |    |
|      +-------------------------------------------------------+    |
|                               | (SQL)                             |
+-------------------------------|-----------------------------------+
                                v
+-------------------------------------------------------------------+
|                         Database (MySQL)                          |
+-------------------------------------------------------------------+
```

-   **用户**通过浏览器访问部署在 3000 端口的 `frontend` 服务。
-   `frontend` 应用内部的 API 请求会被转发到 8080 端口的 `backend` 服务。
-   `backend` 服务在处理业务逻辑时，会与 `db` 服务（MySQL）进行数据读写交互。

## 2. 前端架构 (`frontend`)

前端项目位于 `frontend/` 目录下，是一个基于 **Vite**、**React** 和 **TypeScript** 的单页应用（SPA）。其最大的亮点是在 `src/Core` 目录中实现了一套**实体-组件-系统 (Entity-Component-System, ECS)** 架构。

### 技术栈

-   **构建工具**: Vite
-   **UI 框架**: React
-   **语言**: TypeScript
-   **核心架构**: 自研的 ECS 框架

### ECS 架构详解

ECS 是一种在游戏开发中非常流行的架构模式，它提倡组合而非继承，通过将数据和逻辑分离来提高代码的灵活性和可复用性。在本项目中，ECS 被用来管理画布上的所有可见元素和交互逻辑。

#### 核心概念

1.  **Entity (实体) - `src/Core/Entity/Entity.ts`**
    -   实体是一个唯一的 ID，可以把它看作是一个通用的“游戏对象”或容器。它本身不包含任何数据或逻辑。
    -   在我们的场景里，画布上的一个图形（如矩形、圆形）就是一个实体。

2.  **Component (组件) - `src/Core/Components/`**
    -   组件是纯粹的数据容器，用来描述实体的某个方面的属性。每个组件只负责一件事情。
    -   例如：
        -   `Position.ts`: 存储实体的 (x, y) 坐标。
        -   `Size.ts`: 存储实体的宽度和高度。
        -   `Color.ts`: 存储实体的颜色。
    -   一个实体可以附加多个组件。例如，一个彩色的矩形实体会同时拥有 `Position`、`Size` 和 `Color` 组件。

3.  **System (系统) - `src/Core/System/`**
    -   系统是纯粹的逻辑单元，它不包含任何状态（数据）。
    -   每个系统会持续查询具有特定组件组合的实体，并对这些实体执行操作。
    -   例如：
        -   `RenderSystem.ts`: 查询所有拥有 `Position`、`Size` 和 `Color` 组件的实体，并将它们绘制到 Canvas 上。
        -   `InputSystem.ts`: 监听用户的鼠标点击事件，判断是否选中了某个实体。
        -   `SelectionSystem.ts`: 处理实体的选中状态，例如为选中的实体添加一个高亮边框（通过添加一个 `Selection` 组件）。

### 目录结构与职责

-   `src/Canvas/Canvas.tsx`: React 组件，负责创建和管理 HTML5 Canvas 元素，并初始化 ECS 核心 `Core`。
-   `src/Core/Core.ts`: ECS 引擎的核心，负责管理所有的实体、组件和系统，并驱动主循环（game loop）。
-   `src/Core/DSL/DSL.ts`: 可能是一个领域特定语言（DSL）的实现，用于以声明式的方式创建实体和组件，简化场景构建。

这种架构使得前端代码非常灵活。例如，如果想让一个物体能够移动，我们只需要为其添加一个 `Velocity` 组件，并创建一个 `MovementSystem` 来根据速度更新 `Position` 组件即可，而无需修改任何现有代码。

## 3. 后端架构 (`backend`)

后端项目位于 `backend/` 目录下，是一个使用 **Go** 语言编写的 Web 服务。它采用了经典的分层架构，使得代码职责清晰，易于维护和扩展。

### 技术栈

-   **Web 框架**: Gin
-   **ORM**: GORM
-   **API 文档**: Swagger
-   **RPC 框架**: gRPC

### 分层架构详解

后端代码遵循了清晰的依赖规则，上层依赖下层，核心业务逻辑位于 `service` 层。

1.  **Router (路由层) - `router/`**
    -   职责：定义 API 路由规则，将 HTTP 请求映射到对应的 `handler` 函数。
    -   使用 Gin 框架实现，例如 `user_router.go` 定义了所有与用户相关的 URL。

2.  **Middleware (中间件层) - `middleware/`**
    -   职责：处理跨领域的通用逻辑，如用户认证、日志记录、请求追踪、异常恢复等。
    -   例如 `jwt.go` 实现了 JWT 令牌的验证，保护需要授权的接口。

3.  **Handler (处理层) - `handler/`**
    -   职责：作为请求的直接处理者。它负责解析 HTTP 请求（如参数、JSON body），调用 `service` 层完成业务逻辑，并最终将结果或错误封装成 HTTP 响应返回给客户端。
    -   这一层是 HTTP 世界和 Go 世界的桥梁。

4.  **Service (服务/业务逻辑层) - `service/`**
    -   职责：实现核心的业务逻辑。这是整个后端应用的心脏。
    -   它不关心数据来自 HTTP 还是 gRPC，也不关心数据如何存储。它只专注于业务规则。例如，`users_service.go` 中会包含用户注册、登录、权限检查等核心功能。

5.  **Repository (仓库/数据访问层) - `repo/`**
    -   职责：负责与数据库进行交互，提供数据的增删改查（CRUD）操作。
    -   使用 GORM 作为 ORM 框架，将 Go 的 `struct` 和数据库的 `table` 进行映射。
    -   `service` 层通过调用 `repository` 层来获取和持久化数据，从而将业务逻辑与数据存储细节解耦。

6.  **Model (模型层) - `model/`**
    -   职责：定义与数据库表结构对应的 Go `struct`。这些模型被 GORM 用来执行数据库操作。

### gRPC 的使用

项目中包含了 `internal/grpc` 目录，这表明后端也集成了 gRPC 服务。这可能用于：

-   **内部 RPC 调用**: 如果未来系统扩展为多个微服务，服务之间可以通过 gRPC 进行高效的通信。
-   **提供高性能接口**: 为某些特定场景（如需要流式传输或低延迟的场景）提供 gRPC 接口，作为 RESTful API 的补充。

`build_proto.sh` 脚本用于从 `.proto` 文件自动生成 Go 代码，这是 gRPC 开发的标准流程。

## 4. 数据库 (`db`)

-   **类型**: MySQL 8.0
-   **ORM**: 后端通过 GORM 与数据库交互，简化了 SQL 操作。
-   **数据卷**: `docker-compose.yml` 中定义了 `dbdata` 数据卷，确保数据库在容器重启后数据不会丢失。

## 5. 部署与运维

整个项目通过 `docker-compose.yml` 文件进行统一管理和部署，体现了“基础设施即代码”的思想。

-   **服务构建**: `frontend` 和 `backend` 都有各自的 `Dockerfile`（虽然未在目录树中直接展示，但 `build` 指令暗示了其存在），用于构建独立的服务镜像。
-   **服务编排**: `docker-compose` 负责启动和连接所有服务，包括设置端口映射和环境变量。
-   **开发环境**: 开发者只需安装 Docker，即可一键启动整个开发环境，极大地简化了环境配置的复杂性。

## 总结

`duck-core` 是一个设计精良的全栈项目。

-   **前端**通过引入 ECS 架构，为处理复杂的、动态的画布场景提供了一个高度模块化和可扩展的解决方案，这在传统的 Web 开发中是一个非常新颖和强大的尝试。
-   **后端**则采用了成熟的 Go 分层架构，保证了代码的健壮性、可维护性和高性能。

无论是对于想学习 Go 后端开发的同学，还是对于希望在前端领域探索非传统架构的前端工程师，`duck-core` 都是一个非常值得学习和借鉴的优秀案例。
